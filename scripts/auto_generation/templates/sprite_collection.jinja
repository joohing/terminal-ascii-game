// NOTE: THIS FILE IS AUTOGENERATED. ANY MANUAL CHANGES WILL BE OVERWRITTEN


const std = @import("std");


pub const Sprite = struct {
    data: []const u8,
    stride_length: u8,
    headers: Headers,
};


pub const SpriteCollection = struct {{'{'}}
    {% for sprite_name in sprite_names %}{{sprite_name}}: Sprite,
    {% endfor %}
{{'}'}};


const HeaderInitError = error{{'{'}}
    InvalidNumberOfArgs,
    IncorrectArgumentType,
{{'}'}};

const Headers = struct {{'{'}}{% for field, field_info in sprite_headers.items() %}{{field}}: {{field_info["type"]}},
    {% endfor %}
    fn init(header_str: []u8) !Headers {{'{'}}
        {% if sprite_headers.__len__() == 0 %}
        _ = header_str;
        return Headers{{'{'}}{{'}'}};
        {% else %}
        var args: [{{sprite_headers.__len__()}}][32]u8 = undefined;
        var arg_count: u32 = 0;
        for (std.mem.splitAny(u8, header_str, ","), 0..) |arg, index| {{'{'}}
            args[index] = arg;
            arg_count += 1;
        {{'}'}}

        if (arg_count != 1) {{'{'}}
            var msg_buffer: [256]u8 = undefined;
            const full_msg = std.fmt.bufPrint(&msg_buffer, "Error during extraction of headers in sprite file '{{sprite_name}}.sprite'. Expected {{sprite_headers.__len__()}} argument on the header line, but found {}\n", .{arg_count});
            return HeaderInitError.InvalidNumberOfArgs(full_msg);
        {{'}'}}
        {% for field, field_info in sprite_headers.items() %}
        const {{field}} = {{field_info["coercion"].format(arg="args[" + loop.index0.__str__() +"]")}} catch {{'{'}}
            return HeaderInitError.IncorrectArgumentType("File: '{{SPRITE_NAME}}'.sprite, argument: '{{field}}'");
        {{'}'}};
        {% endfor %}
        return Headers{{'{'}}{% for field in sprite_fields %}
            .{{field}} = {{field}},{% endfor %}
        {{'}'}};
        {% endif %}
    {{'}'}}
{{'}'}};

pub fn load_sprite_collection(allocator: *std.mem.Allocator) !SpriteCollection {{'{'}}{% for sprite_name in sprite_names %}
    const {{sprite_name}}_file = try std.fs.cwd().openFile("assets/sprites/{{sprite_name}}.sprite", .{});
    const {{sprite_name}}_file_size: u64 = (try {{sprite_name}}_file.stat()).size;
    var {{sprite_name}}_content = try allocator.alloc(u8, @intCast({{sprite_name}}_file_size));
    _ = try {{sprite_name}}_file.read({{sprite_name}}_content);
    const {{sprite_name}}_header_content = {{sprite_name}}_content[0..find_first_newline({{sprite_name}}_content)];
    const {{sprite_name}}_header = try Headers.init({{sprite_name}}_header_content);
    const {{sprite_name}}_stride = find_stride_of({{sprite_name}}_content);
    const {{sprite_name}}_newline_count = std.mem.count(u8, {{sprite_name}}_content, "\n") + 1; // Plus one cause no newline at end of file

    const {{sprite_name}}_padded_file_size = {{sprite_name}}_stride * {{sprite_name}}_newline_count;
    std.debug.print("Size allocated: {d} x {d} = {d} for sprite: {{sprite_name}}\n", .{
        {{sprite_name}}_stride,
        {{sprite_name}}_newline_count,
        {{sprite_name}}_padded_file_size
    });

    const {{sprite_name}}_content_padded = try allocator.alloc(u8, @intCast({{sprite_name}}_padded_file_size));
    right_pad_sprite({{sprite_name}}_content_padded, {{sprite_name}}_content, {{sprite_name}}_stride);

    _ = std.mem.replace(u8, {{sprite_name}}_content, "\n", "", {{sprite_name}}_content);

    {% endfor %}

    return SpriteCollection {{'{'}}{% for sprite_name in sprite_names %}
        .{{sprite_name}} = Sprite {
            .data={{sprite_name}}_content_padded,
            .stride_length=@intCast({{sprite_name}}_stride),
            .headers={{sprite_name}}_header,
        },
    {% endfor %}
    {{'}'}};
{{'}'}}

fn find_stride_of(buffer: []u8) usize {
    var max_line_len: usize = 0;
    var line_len: usize = 0;

    for (buffer) |char| {
        if (char == 10) {
            line_len = 0;
        } else {
            line_len += 1;
        }
        if (max_line_len < line_len) {
            max_line_len = line_len;
        }
    }

    return max_line_len;
}

fn find_first_newline(buffer: []u8) usize {
    for (buffer, 0..) |char, index| {
        if (char == 10) {
            return index;
        }
    }
    return 0;
}

fn find_longest_line(buffer: []u8) usize {
    var splitboi = std.mem.splitScalar(u8, buffer, '\n');
    var curr_len: usize = 0;

    while (splitboi.next()) |val| {
        if (val.len > curr_len) {
            curr_len = val.len;
        }
    }

    return curr_len;
}

fn right_pad_sprite(buffer_write: []u8, buffer_read: []u8, stride_length: usize) void {
    var spliterator = std.mem.splitScalar(u8, buffer_read, '\n');
    var ptr: usize = 0;

    while (spliterator.next()) |val| {
        for (0..val.len) |i| {
            buffer_write[ptr + i] = val[i];
        }
        if (val.len < stride_length) {
            for (val.len..stride_length) |i| {
                buffer_write[ptr + i] = ' ';
            }
        }
        ptr += stride_length;
    }
}
