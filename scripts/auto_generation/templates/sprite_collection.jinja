// NOTE: THIS FILE IS AUTOGENERATED. ANY MANUAL CHANGES WILL BE OVERWRITTEN

const std = @import("std");
const helpers = @import("helpers");

pub const Sprite = struct {
    data: []const u8,
    stride_length: u8,
    headers: Headers,
    curr_frame: []u8,
};

pub const SpriteCollection = struct {{'{'}}
    {% for sprite_name in sprite_names %}{{sprite_name}}: Sprite,
    {% endfor %}
{{'}'}};

const HeaderInitError = error{{'{'}}
    InvalidNumberOfArgs,
    IncorrectArgumentType,
    UnexpectedRotation,
{{'}'}};

const SpriteLoadError = error{{'{'}}
    InvalidNumberOfArgs,
    EmptySprite,
    NoNewline,
{{'}'}};

const Headers = struct {{'{'}}
    {% for field, field_info in sprite_headers.items() %}
    {{field}}: {{field_info["type"]}},
    {% endfor %}

    fn init(header_str: []u8) !Headers {{'{'}}
        {% if sprite_headers.__len__() == 0 %}
        _ = header_str;
        return Headers{{'{'}}{{'}'}};
        {% endif %}

        var args: [{{sprite_headers.__len__()}}][]const u8 = undefined;
        var arg_count: u32 = 0;
        var spliterator = std.mem.splitAny(u8, header_str, ",");
        while (spliterator.next()) |arg| {{'{'}}
            args[arg_count] = arg;
            arg_count += 1;
        {{'}'}}

        if (arg_count != {{sprite_headers.__len__()}}) {{'{'}}
            {# var msg_buffer: [256]u8 = undefined; #}
            {# const full_msg = std.fmt.bufPrint(&msg_buffer, "Error during extraction of headers in sprite file '{{sprite_name}}.sprite'. Expected {{sprite_headers.__len__()}} argument on the header line, but found {}\n", .{arg_count}); #}
            return HeaderInitError.InvalidNumberOfArgs;
        {{'}'}}

        {% for field, field_info in sprite_headers.items() %}
        const {{field}} = {{field_info["coercion"].format(arg="args[" + loop.index0.__str__() +"]")}} catch |e| {{'{'}}
            std.debug.print("Failed to load header {{field}}. Got {{'{'}}s{{'}'}}.", .{{'{'}}args[{{loop.index0.__str__()}}]{{'}'}});
            return switch (e) {{'{'}}
                else => e,
                {# HeaderInitError.UnexpectedRotation => e,
                else => HeaderInitError.IncorrectArgumentType, //("File: ''.sprite, argument: 'rotation'"), #}
            {{'}'}};
        {{'}'}};
        {% endfor %}

        return Headers{{'{'}}{% for field in sprite_headers.keys() %}
            .{{field}} = {{field}},{% endfor %}
        {{'}'}};
    {{'}'}}
{{'}'}};

pub fn load_sprite_collection(allocator: *std.mem.Allocator) !SpriteCollection {{'{'}}{% for sprite_name in sprite_names %}
    const {{sprite_name}}_file = try std.fs.cwd().openFile("assets/sprites/{{sprite_name}}.sprite", .{});
    const {{sprite_name}}_file_size: u64 = (try {{sprite_name}}_file.stat()).size;
    var {{sprite_name}}_content = try allocator.alloc(u8, @intCast({{sprite_name}}_file_size));

    _ = try {{sprite_name}}_file.read({{sprite_name}}_content);

    if ({{sprite_name}}_content[{{sprite_name}}_content.len-1] != '\n') {
        std.debug.print("Sprite '{{sprite_name}}.sprite' must end in a newline\n", .{{'{}'}});
        return SpriteLoadError.NoNewline;
    }

    const {{sprite_name}}_header_content = {{sprite_name}}_content[0..find_first_newline({{sprite_name}}_content)];
    //std.debug.print("First newline for {{sprite_name}}: {{'{}'}}", .{{'{'}}find_first_newline({{sprite_name}}_content){{'}'}});
    {{sprite_name}}_content = {{sprite_name}}_content[find_first_newline({{sprite_name}}_content)+1..];
    const {{sprite_name}}_stride = find_stride_of({{sprite_name}}_content);

    const {{sprite_name}}_header = Headers.init({{sprite_name}}_header_content) catch |e| {{'{'}}
        std.debug.print("Failed loading headers for file '{{sprite_name}}.sprite'. Header content: {{'{'}}s{{'}'}}\n", .{{'{'}}{{sprite_name}}_header_content{{'}'}});
        return e;
    {{'}'}};

    if ({{sprite_name}}_content.len == 0) {
        std.debug.print("Sprite '{{sprite_name}}.sprite' with header '{{'{}'}}'' has no content.\n", .{{'{'}}{{sprite_name}}_header{{'}'}});
        return SpriteLoadError.EmptySprite;
    }

    const {{sprite_name}}_newline_count: usize = std.mem.count(u8, {{sprite_name}}_content, "\n");

    const {{sprite_name}}_padded_file_size = {{sprite_name}}_stride * {{sprite_name}}_newline_count;
    std.debug.print("Size allocated: {d} x {d} = {d} for sprite: {{sprite_name}}\n", .{
        {{sprite_name}}_stride,
        {{sprite_name}}_newline_count,
        {{sprite_name}}_padded_file_size
    });

    const {{sprite_name}}_content_padded = try allocator.alloc(u8, @intCast({{sprite_name}}_padded_file_size));
    right_pad_sprite({{sprite_name}}_content_padded, {{sprite_name}}_content, {{sprite_name}}_stride);

    const {{sprite_name}}_bytes_per_frame = {{sprite_name}}_stride * {{sprite_name}}_header.lines_per_frame;

    {% endfor %}

    const collection = SpriteCollection {{'{'}}{% for sprite_name in sprite_names %}
        .{{sprite_name}} = Sprite {
            .data={{sprite_name}}_content_padded,
            .stride_length=@intCast({{sprite_name}}_stride),
            .headers={{sprite_name}}_header,
            .curr_frame={{sprite_name}}_content_padded[0..{{sprite_name}}_bytes_per_frame],
        },
    {% endfor %}
    {{'}'}};

    std.debug.print("Loaded sprites: {}\n", .{collection});
    return collection;
{{'}'}}

fn find_stride_of(buffer: []u8) usize {
    var max_line_len: usize = 0;
    var line_len: usize = 0;

    for (buffer) |char| {
        if (char == 10) {
            line_len = 0;
        } else {
            line_len += 1;
        }
        if (max_line_len < line_len) {
            max_line_len = line_len;
        }
    }

    return max_line_len;
}

fn find_first_newline(buffer: []u8) usize {
    for (buffer, 0..) |char, index| {
        if (char == 10) {
            return index;
        }
    }
    return buffer.len;
}

fn find_longest_line(buffer: []u8) usize {
    var splitboi = std.mem.splitScalar(u8, buffer, '\n');
    var curr_len: usize = 0;

    while (splitboi.next()) |val| {
        if (val.len > curr_len) {
            curr_len = val.len;
        }
    }

    return curr_len;
}

fn right_pad_sprite(buffer_write: []u8, buffer_read: []u8, stride_length: usize) void {
    var spliterator = std.mem.splitScalar(u8, buffer_read, '\n');
    var ptr: usize = 0;

    while (spliterator.next()) |val| {
        if (val.len == 0) {
            continue;
        }
        for (0..val.len) |i| {  // Minus one to avoid whitespace due to newline at the end of sprite
            buffer_write[ptr + i] = val[i];
        }
        if (val.len < stride_length) {
            for (val.len..stride_length) |i| {
                buffer_write[ptr + i] = ' ';
            }
        }
        ptr += stride_length;
    }
}
