// NOTE: THIS FILE IS AUTOGENERATED. ANY MANUAL CHANGES WILL BE OVERWRITTEN


const std = @import("std");


pub const Sprite = struct {
    data: []const u8,
    stride_length: u8,
    headers: Headers,
};


pub const SpriteCollection = struct {{'{'}}
    {% for sprite_name in sprite_names %}{{sprite_name}}: Sprite,
    {% endfor %}
{{'}'}};


const HeaderInitError = error{{'{'}}
    InvalidNumberOfArgs,
    IncorrectArgumentType,
{{'}'}};

const Headers = struct {{'{'}}{% for field, field_info in sprite_headers.items() %}{{field}}: {{field_info["type"]}},
    {% endfor %}
    fn init(header_str: []u8) !Headers {{'{'}}
        {% if sprite_headers.__len__() == 0 %}
        _ = header_str;
        return Headers{{'{'}}{{'}'}};
        {% else %}
        var args: [{{sprite_headers.__len__()}}][32]u8 = undefined;
        var arg_count: u32 = 0;
        for (std.mem.splitAny(u8, header_str, ","), 0..) |arg, index| {{'{'}}
            args[index] = arg;
            arg_count += 1;
        {{'}'}}

        if (arg_count != 1) {{'{'}}
            var msg_buffer: [256]u8 = undefined;
            const full_msg = std.fmt.bufPrint(&msg_buffer, "Error during extraction of headers in sprite file '{{sprite_name}}.sprite'. Expected {{sprite_headers.__len__()}} argument on the header line, but found {}\n", .{arg_count});
            return HeaderInitError.InvalidNumberOfArgs(full_msg);
        {{'}'}}
        {% for field, field_info in sprite_headers.items() %}
        const {{field}} = {{field_info["coercion"].format(arg="args[" + loop.index0.__str__() +"]")}} catch {{'{'}}
            return HeaderInitError.IncorrectArgumentType("File: '{{SPRITE_NAME}}'.sprite, argument: '{{field}}'");
        {{'}'}};
        {% endfor %}
        return Headers{{'{'}}{% for field in sprite_fields %}
            .{{field}} = {{field}},{% endfor %}
        {{'}'}};
        {% endif %}
    {{'}'}}
{{'}'}};


pub fn load_sprite_collection(allocator: *std.mem.Allocator) !SpriteCollection {{'{'}}{% for sprite_name in sprite_names %}
    const {{sprite_name}}_file = try std.fs.cwd().openFile("assets/sprites/{{sprite_name}}.sprite", .{});
    const {{sprite_name}}_file_size: u64 = (try {{sprite_name}}_file.stat()).size;
    var {{sprite_name}}_content = try allocator.alloc(u8, @intCast({{sprite_name}}_file_size));
    _ = try {{sprite_name}}_file.read({{sprite_name}}_content);
    const {{sprite_name}}_header_content = {{sprite_name}}_content[0..find_first_newline({{sprite_name}}_content)];
    const {{sprite_name}}_header = try Headers.init({{sprite_name}}_header_content);
    const {{sprite_name}}_stride = find_first_newline({{sprite_name}}_content);
    const {{sprite_name}}_newline_count = std.mem.replace(u8, {{sprite_name}}_content, "\n", "", {{sprite_name}}_content);
    {{sprite_name}}_content = {{sprite_name}}_content[0 .. {{sprite_name}}_content.len - {{sprite_name}}_newline_count];
    
    

    {% endfor %}


    return SpriteCollection {{'{'}}{% for sprite_name in sprite_names %}
        .{{sprite_name}} = Sprite {
            .data={{sprite_name}}_content,
            .stride_length=@intCast({{sprite_name}}_stride),
            .headers={{sprite_name}}_header,
        },
    {% endfor %}
    {{'}'}};
    
    
{{'}'}}


fn find_first_newline(buffer: []u8) usize {
    for (buffer, 0..) |char, index| {
        if (char == 10) {
            return index;
        }
    }
    return 0;
}

fn find_longest_line(buffer: []u8) usize {
    var splitboi = std.mem.splitScalar(u8, buffer, '\n');
    var curr_len: usize = 0;

    while (splitboi.next()) |val| {
        if (val.len > curr_len) {
            curr_len = val.len;
        }
    }

    return curr_len;
}
{# 
fn right_pad_sprite(buffer_write: []u8, buffer_read: []u8, stride_length: usize) void {
    var spliterator = std.mem.splitScalar(u8, buffer_read, '\n');

    while (spliterator.next()) |val| {
        if (val.len == stride_length) {
            buffer_write += val;
        } else {
            const padding = .{' ' ** stride_length - val.len};
            buffer_write += val + padding;
        }
    }

    return buffer_write;
} #}
